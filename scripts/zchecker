#!/usr/bin/env python3
import os
import re
import sys
import argparse

import numpy as np
import astropy.units as u
from astropy.time import Time

from zchecker import ZChecker, Config
from zchecker.config import _config_example


def object_list(olist):
    import os
    if os.path.exists(olist):
        with open(olist) as f:
            objects = [s.strip() for s in f.readlines()]
            objects = [s for s in objects if not s.startswith('#')]
    else:
        objects = [s.strip() for s in olist.split(',')]
    return objects


def test_date(date):
    if date is not None:
        if not re.match('^20[12][0-9]-[01][0-9]-[0-3][0-9]$', date):
            raise ValueError(
                'Bad date: {}; date format is YYYY-MM-DD.'.format(date))


def as_time(a):
    test_date(a)
    return Time(a)


# create the top-level parser
# Configuration file format should match the description in zchecker.config.
parser = argparse.ArgumentParser(prog='zchecker', description='ZTF small-body search tool.', epilog='''
Configuration file format:

{}
'''.format(_config_example), formatter_class=argparse.RawTextHelpFormatter)

parser.add_argument('--db', help='database file')
parser.add_argument('--log', help='log file')
parser.add_argument('--config', default=os.path.expanduser(
    '~/.config/zchecker.config'), help='configuration file')
parser.add_argument('-v', action='store_true', help='increase verbosity')
subparsers = parser.add_subparsers(help='sub-commands')

today = Time(Time.now().iso[:10])

## SEARCH ############################################################


def search(args):
    start = args.start
    stop = args.stop
    all_dates_none = all([x is None for x in
                          [args.date, args.start, args.stop]])
    if args.full:
        start = None
        stop = None
    elif all_dates_none:
        start = today
        stop = today
    elif args.date is not None:
        start = args.date
        stop = args.date

    if stop is not None:
        stop = stop + 1 * u.day  # search limit is end of the day

    config = Config.from_args(args)
    with ZChecker(config, save_log=True) as z:
        if args.objects is None:
            objects = z.db.get_objects()[1]
        else:
            objects = args.objects

        try:
            tab = z.find_objects(objects, start=start, stop=stop,
                                 vmax=args.vmax, save=(not args.print),
                                 update=args.update)
        except Exception as e:
            z.logger.error(str(e))
            raise e

        if args.print:
            tab.pprint(max_lines=-1, max_width=-1)


parser_search = subparsers.add_parser(
    'search', help='search ZTF fields in local database',
    epilog='Date format: YYYY-MM-DD.  Object designations must be in'
    ' the local database.')
parser_search.add_argument(
    'objects', type=object_list, nargs='?',
    help='file name listing one object per line, or a comma-separated'
    ' list of objects; default is to search all targets in the ephemeris'
    ' database defined over the requested date range')
parser_search.add_argument(
    '--print', action='store_true',
    help='print results; do not save to database')
parser_search.add_argument(
    '--update', action='store_true',
    help='update metadata for found objects already found')
mutex = parser_search.add_mutually_exclusive_group()
mutex.add_argument(
    '--full', action='store_true', help='search all available nights')
mutex.add_argument(
    '--date', type=as_time,
    help='search a single date, UT (default today)')
mutex.add_argument(
    '--start', type=as_time,
    help='search a range of dates, beginning with this date, UT')
parser_search.add_argument(
    '--stop', type=as_time,
    help='search a range of dates, ending with this date, UT')
parser_search.add_argument(
    '--vmax', type=float, default=25,
    help='skip epochs when object is fainter than vmax, mag')
parser_search.set_defaults(func=search)

## ONE_SHOT ############################################################


def one_shot(args):
    start = args.start
    stop = args.stop + 1 * u.day  # search limit is end of the day
    epochs = {
        'start': start.iso[:10],
        'stop': stop.iso[:10],
        'step': args.step
    }

    config = Config.from_args(args)
    with ZChecker(config, save_log=True) as z:
        try:
            eph = z.db.get_ephemeris_exact(
                args.object, 'I41', epochs, source=args.source)
            n, obs, tab = z.find_by_ephemeris(eph)
        except Exception as e:
            z.logger.error(str(e))
            raise e

        tab.pprint(max_lines=-1, max_width=-1)


parser_one_shot = subparsers.add_parser(
    'one-shot', help='search ZTF fields on the fly',
    epilog='Date format: YYYY-MM-DD.')
parser_one_shot.add_argument(
    'object',
    help='object designation to resolve')
parser_one_shot.add_argument(
    'start', type=as_time, help='search beginning with this date, UT')
parser_one_shot.add_argument(
    'stop', type=as_time, help='search ending with this date, UT')
parser_one_shot.add_argument(
    '--source', choices=['jpl', 'mpc'], default='jpl',
    help='base search on ephemerides from JPL or MPC')
parser_one_shot.add_argument(
    '--step', default='1d', help='step size for ephemeris generation')
parser_one_shot.set_defaults(func=one_shot)

# EPH-UPDATE ############################################################


def eph_update(args):
    stop = args.stop + 1 * u.day  # place limit at end of day
    config = Config.from_args(args)
    with ZChecker(config, save_log=True) as z:
        try:
            if args.clean:
                z.clean_ephemeris(args.objects, args.start, stop)
            else:
                z.update_ephemeris(args.objects, args.start, stop)
        except Exception as e:
            z.logger.error(str(e))
            raise e


parser_eph = subparsers.add_parser(
    'eph-update', help='update local ephemeris database',
    aliases=['eph'], epilog='Date format: YYYY-MM-DD.')
parser_eph.add_argument(
    'objects', type=object_list,
    help='file name listing one object per line, or a comma-separated'
    ' list of objects, resolvable by JPL/Horizons')
parser_eph.add_argument(
    '--start', default=as_time('2017-10-13'), type=as_time,
    help='start date of ephemeris, UT')
parser_eph.add_argument(
    '--stop', default=as_time('2019-01-01'), type=as_time,
    help='stop date of ephemeris, UT')
parser_eph.add_argument(
    '--clean', action='store_true', help='delete from database')
parser_eph.set_defaults(func=eph_update)

# CLEAN-EPH ############################################################


def clean_eph(args):
    config = Config.from_args(args)
    with ZChecker(config, save_log=True) as z:
        try:
            z.clean_ephemeris(args.objects, start=args.start, stop=args.stop)
        except Exception as e:
            z.logger.error(str(e))
            raise e


parser_cleph = subparsers.add_parser(
    'clean-eph', help='clean local ephemeris database',
    epilog=('Date format: YYYY-MM-DD.  Date interval is inclusive.  '
            'Default is to remove the entire ephemeris.'))
parser_cleph.add_argument(
    'objects', type=object_list,
    help=('file name listing one object per line, or a comma-separated '
          'list of objects'))
parser_cleph.add_argument(
    '--start', type=as_time, help='start date of ephemeris to remove, UT')
parser_cleph.add_argument(
    '--stop', type=as_time, help='stop date of ephemeris to remove, UT')
parser_cleph.set_defaults(func=clean_eph)

# CLEAN-FOUND ############################################################


def clean_found(args):
    config = Config.from_args(args)
    with ZChecker(config, save_log=True) as z:
        try:
            z.clean_found(args.objects, start=args.start, stop=args.stop)
        except Exception as e:
            z.logger.error(str(e))
            raise e


parser_found = subparsers.add_parser(
    'clean-found', help='clean found object database and data archive',
    epilog='Date format: YYYY-MM-DD.  Date interval is inclusive.  Default is to remove all findings.  Files in the cutouts directory will also be removed.')
parser_found.add_argument(
    'objects', type=object_list,
    help='file name listing one object per line, or a comma-separated'
    ' list of objects, must be resolvable by JPL/Horizons')
parser_found.add_argument(
    '--start', type=as_time, help='start date to remove, UT')
parser_found.add_argument(
    '--stop', type=as_time, help='stop date to remove, UT')
parser_found.set_defaults(func=clean_found)

# ZTF-UPDATE ############################################################


def ztf_update(args):
    start = args.start
    stop = args.stop
    date = args.date

    if date is None:
        date = today

    if start is None:
        start = date

    if stop is None:
        stop = date

    if start > stop:
        raise ValueError('Start date must occur before stop date.')

    config = Config.from_args(args)
    with ZChecker(config, save_log=True) as z:
        while start <= stop:
            try:
                d = start.iso[:10]
                z.update_observations(d, d)
                start = start + 1 * u.day
            except Exception as e:
                z.logger.error(str(e))
                raise e


parser_ztf = subparsers.add_parser(
    'ztf-update', help='update local ZTF database', aliases=['ztf'])
parser_ztf.add_argument(
    '--date', type=as_time, help='retrieve observations for this date, UT')
parser_ztf.add_argument(
    '--start', type=as_time, help='start date to retrieve, UT')
parser_ztf.add_argument(
    '--stop', type=as_time, help='stop date to retrieve, UT')

parser_ztf.set_defaults(func=ztf_update)

# GET-CUTOUTS ############################################################


def download_cutouts(args):
    config = Config.from_args(args)
    with ZChecker(config, save_log=True) as z:
        try:
            z.download_cutouts(
                desg=args.desg, clean_failed=args.clean_failed,
                retry_failed=args.retry_failed)
        except Exception as e:
            z.logger.error(str(e))
            raise e


parser_cutout = subparsers.add_parser(
    'download-cutouts', help='download cutouts.', aliases=['cutouts'])
parser_cutout.add_argument(
    '--desg', help='only download cutouts for this target')
parser_cutout.add_argument(
    '--path', help='local cutout path')
parser_cutout.add_argument(
    '--leave-failed', dest='clean_failed', action='store_false',
    help='Leave empty file after failed download.')
parser_cutout.add_argument(
    '--retry-failed', action='store_true',
    help='Retry previously failed science image syncs.')
parser_cutout.set_defaults(func=download_cutouts)

# LIST-NIGHTS ############################################################


def list_nights(args):
    config = Config.from_args(args)
    with ZChecker(config, save_log=False, disable_log=True) as z:
        try:
            tab = z.available_nights(count_exposures=args.exposures)
            tab.pprint(max_lines=-1, max_width=-1)
        except Exception as e:
            z.logger.error(str(e))
            raise e


parser_nights = subparsers.add_parser(
    'list-nights', help='list all ZTF nights saved to local database',
    aliases=['nights'])
parser_nights.add_argument(
    '--no-exposures', dest='exposures',
    action='store_false', help='do not list number of exposures')
parser_nights.set_defaults(func=list_nights)

# LIST-OBJECTS ############################################################


def list_objects(args):
    config = Config.from_args(args)
    with ZChecker(config, disable_log=True) as z:
        try:
            opts = dict(objects=args.objects, start=args.start, stop=args.stop)
            if args.eph:
                tab = z.object_coverage('eph', **opts)
            elif args.found:
                tab = z.object_coverage('found', **opts)
            else:
                tab = z.available_objects()

            for k, v in tab.meta.items():
                print('{}: {}'.format(k, v))

            tab.pprint(max_lines=-1, max_width=-1)
        except Exception as e:
            z.logger.error(str(e))
            raise e


parser_objects = subparsers.add_parser(
    'list-objects', aliases=['objects'],
    help=('list all objects in the local database with their '
          'ephemeris ranges'))
mutex = parser_objects.add_mutually_exclusive_group()
mutex.add_argument(
    '--eph', action='store_true', help='summarize ephemeris coverage')
mutex.add_argument(
    '--found', action='store_true',
    help='summarize objects')
parser_objects.add_argument(
    '--objects', type=object_list,
    help=('summarize these specific objects (comma-separated list or '
          'file name'))
parser_objects.add_argument(
    '--start', type=as_time, help='start date to search for coverage, UT')
parser_objects.add_argument(
    '--stop', type=as_time, help='stop date to search for coverage, UT')
parser_objects.set_defaults(func=list_objects)

########################################################################

args = parser.parse_args()
try:
    getattr(args, 'func')
except AttributeError as e:
    parser.print_help()
    sys.exit()

try:
    args.func(args)
except Exception as e:
    if args.v:
        raise(e)
    else:
        print(str(e))
        sys.exit()
